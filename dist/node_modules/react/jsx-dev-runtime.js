// 为了防止滥用 ReactElement，所以需用通过 Symbol 定义一个独一无二的值
// 判断当前宿主环境是否支持 Symbol
const supportSymbol = typeof Symbol === 'function' && Symbol.for;
const REACT_ELEMENT_TYPE = supportSymbol
    ? Symbol.for('react.element')
    : 0xeac7;

// ReactElement
const ReactElement = function (type, key, ref, props) {
    const element = {
        // 通过 $$typeof 来判断是不是一个 ReactElement
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref,
        props,
        // 和真实的 react 中的 ReactElement 进行区分
        __mark: 'jzy'
    };
    return element;
};
const jsx = (type, config, ...maybeChildren) => {
    let key = null;
    const props = {};
    let ref = null;
    for (const prop in config) {
        const val = config[prop];
        if (prop === 'key') {
            if (val !== undefined) {
                key = '' + val;
            }
            continue;
        }
        if (prop == 'ref') {
            if (val !== undefined) {
                ref = val;
            }
            continue;
        }
        // 是不是 config 自己的 prop, 而不是原型上的
        if ({}.hasOwnProperty.call(config, prop)) {
            props[prop] = val;
        }
    }
    const maybeChildrenLength = maybeChildren.length;
    if (maybeChildren) {
        if (maybeChildrenLength === 1) {
            props.children = maybeChildren[0];
        }
        else {
            props.children = maybeChildren;
        }
    }
    return ReactElement(type, key, ref, props);
};
// 暂时定义开发环境 jsxDEV 和 生产环境 jsx 一致
// 真实的 React 中的 jsxDev 会输出更多的内容，更严格的检查
const jsxDEV = jsx;

export { jsx, jsxDEV };
